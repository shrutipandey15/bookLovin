#!/usr/bin/env python
"""
SVG Animator: A script to create animated SVGs from two static SVG files.

This script can generate SVGs with different animation types:
- loop: The animation plays continuously.
- click: The animation plays once on click.
- control: The animation is controlled by external JavaScript (forward/backward).
- react: Generates a React component that wraps the SVG and controls the animation.
"""

import argparse
import re
import sys
import xml.etree.ElementTree as ET
from enum import Enum

SVG_NS = "http://www.w3.org/2000/svg"
ET.register_namespace("", SVG_NS)  # Register a default namespace

global_config = {"prefix": ""}


class AnimTypes(Enum):
    """Animation flavors."""

    LOOP = "loop"
    CLICK = "click"
    CONTROL = "control"
    REACT = "react"


# Helper function to extract a specific property value from a style string
def get_style_property(style_string, property_name):
    if not style_string:
        return None
    match = re.search(
        f"{re.escape(property_name)}\\s*:\\s*([^;]+)", style_string, re.IGNORECASE
    )
    if match:
        return match.group(1).strip()
    return None


def create_animated_svg(
    svg1_path,
    svg2_path,
    animation_duration_one_way: str,
    anim_type_str: str,
    root_id_override: str | None = None,
    prefix: str = "unnamed",
):
    anim_type = AnimTypes(anim_type_str)  # Convert string to Enum here
    try:
        tree1 = ET.parse(svg1_path)
        root1 = tree1.getroot()
    except FileNotFoundError:
        print(f"Error: File not found: {svg1_path}", file=sys.stderr)
        sys.exit(1)
    except ET.ParseError:
        print(f"Error: Could not parse XML from {svg1_path}", file=sys.stderr)
        sys.exit(1)

    try:
        tree2 = ET.parse(svg2_path)
        root2 = tree2.getroot()
    except FileNotFoundError:
        print(f"Error: File not found: {svg2_path}", file=sys.stderr)
        sys.exit(1)
    except ET.ParseError:
        print(f"Error: Could not parse XML from {svg2_path}", file=sys.stderr)
        sys.exit(1)

    # Build dictionaries of elements keyed by ID for efficient lookup
    # This will find all elements with an 'id' attribute, regardless of type or location
    elements1_by_id = {el.get("id"): el for el in root1.iter() if el.get("id")}
    elements2_by_id = {el.get("id"): el for el in root2.iter() if el.get("id")}
    global_config["prefix"] = prefix

    if not elements1_by_id and not elements2_by_id:
        print(
            "Warning: No elements with IDs found in the SVGs. Animations require elements to have unique IDs to match them.",
            file=sys.stderr,
        )
    elif not elements1_by_id:
        print(f"Warning: No elements with IDs found in {svg1_path}.", file=sys.stderr)
    elif not elements2_by_id:
        print(f"Warning: No elements with IDs found in {svg2_path}.", file=sys.stderr)

    # Calculate total duration for A -> B -> A cycle
    try:
        val_str = animation_duration_one_way.rstrip("ms")
        unit = animation_duration_one_way[len(val_str) :]
        one_way_val = float(val_str)
        total_val = one_way_val * 2
        if total_val.is_integer():
            total_val = int(total_val)
        cycle_duration_str = f"{total_val}{unit}"
    except ValueError:
        print(
            f"Warning: Could not parse animation_duration_one_way: {animation_duration_one_way}. Defaulting cycle duration to '2s'.",
            file=sys.stderr,
        )
        cycle_duration_str = "2s"

    def _add_animation_if_different(
        parent_element,
        attribute_name,
        val1,
        val2,
        one_way_duration: str,
        cycle_duration: str,
        anim_type: AnimTypes,
        current_animations_count_for_id: int,  # Used for ID generation in loop/click
        trigger_event_id_for_click: str = None,  # For click-triggered animations
    ):
        if val1 == val2:
            return 0  # No animation needed, 0 animations added
        animations_created_count = 0

        if anim_type == AnimTypes.CONTROL or anim_type == AnimTypes.REACT:
            # Forward animation (A -> B)
            animate_fwd = ET.SubElement(parent_element, "animate")
            animate_fwd.set("class", global_config["prefix"] + "forward-anim")
            animate_fwd.set("attributeName", attribute_name)
            animate_fwd.set("values", f"{val1};{val2}")
            animate_fwd.set("dur", one_way_duration)
            animate_fwd.set("begin", "indefinite")
            animate_fwd.set("fill", "freeze")
            animations_created_count += 1

            # Backward animation (B -> A)
            animate_bwd = ET.SubElement(parent_element, "animate")
            animate_bwd.set("class", global_config["prefix"] + "backward-anim")
            animate_bwd.set("attributeName", attribute_name)
            animate_bwd.set("values", f"{val2};{val1}")  # Reverse values
            animate_bwd.set("dur", one_way_duration)
            animate_bwd.set("begin", "indefinite")
            animate_bwd.set("fill", "freeze")
            animations_created_count += 1
        else:  # LOOP or CLICK
            animate_el = ET.SubElement(parent_element, "animate")
            animate_el.set("attributeName", attribute_name)
            animate_el.set("values", f"{val1};{val2};{val1}")
            animate_el.set("dur", cycle_duration)

            if anim_type == AnimTypes.CLICK.value and trigger_event_id_for_click:
                animate_el.set("begin", trigger_event_id_for_click)
            elif anim_type == AnimTypes.LOOP.value:
                animate_el.set("repeatCount", "indefinite")
                animate_el.set("begin", "0s")  # Start immediately
            # Default for non-looping is effectively one cycle if begin is specified.
            animations_created_count += 1
        return animations_created_count

    animations_added = 0
    trigger_event_id = None
    actual_root_id = root_id_override or root1.get("id") or "animatedSvgRoot"
    root1.set("id", actual_root_id)
    # Store one-way duration for JS access
    root1.set("data-one-way-duration", animation_duration_one_way)

    click_to_animate = anim_type == AnimTypes.CLICK.value
    is_react_component = anim_type == AnimTypes.REACT

    if is_react_component:
        root1.set("ref", actual_root_id)

    if click_to_animate:
        trigger_event_id = f"{actual_root_id}.click"

    processed_ids = set()

    for id_val, el1 in elements1_by_id.items():
        if id_val in elements2_by_id:
            el2 = elements2_by_id[id_val]
            processed_ids.add(id_val)

            # Animate 'd' attribute (path data) - specific to paths
            if el1.tag == f"{{{SVG_NS}}}path" and el2.tag == f"{{{SVG_NS}}}path":
                d1 = el1.get("d", "")
                d2 = el2.get("d", "")
                num_created = _add_animation_if_different(
                    el1,
                    "d",
                    d1,
                    d2,
                    animation_duration_one_way,
                    cycle_duration_str,
                    anim_type,
                    animations_added,
                    trigger_event_id,
                )
                animations_added += num_created

            # Animate 'style' attribute
            style1 = el1.get("style", "")
            style2 = el2.get("style", "")
            num_created = _add_animation_if_different(
                el1,
                "style",
                style1,
                style2,
                animation_duration_one_way,
                cycle_duration_str,
                anim_type,
                animations_added,
                trigger_event_id,
            )
            animations_added += num_created

            # Animate common presentation attributes
            common_attrs_to_animate = {
                "stroke": "none",
                "stroke-width": "1",  # Default for stroke-width if not specified
                "opacity": "1",  # Default for opacity
                "fill": "none",  # Default for fill
            }
            for attr, default_val in common_attrs_to_animate.items():
                val1_attr = el1.get(attr)
                val1_style = get_style_property(style1, attr)
                val1 = val1_attr or val1_style or default_val

                val2_attr = el2.get(attr)
                val2_style = get_style_property(style2, attr)
                val2 = val2_attr or val2_style or default_val

                num_created = _add_animation_if_different(
                    el1,
                    attr,
                    val1,
                    val2,
                    animation_duration_one_way,
                    cycle_duration_str,
                    anim_type,
                    animations_added,
                    trigger_event_id,
                )
                animations_added += num_created

            # Animate direct 'transform' attribute
            t1_val = el1.get("transform", "")
            t2_val = el2.get("transform", "")
            num_created = _add_animation_if_different(
                el1,
                "transform",
                t1_val,
                t2_val,
                animation_duration_one_way,
                cycle_duration_str,
                anim_type,
                animations_added,
                trigger_event_id,
            )
            animations_added += num_created
        else:
            sys.stderr.write(
                f"Info: Element with ID '{id_val}' found in first SVG but not in second. Skipping.\n"
            )

    for id_val in elements2_by_id:
        if id_val not in processed_ids:
            sys.stderr.write(
                f"Info: Element with ID '{id_val}' found in second SVG but not in first. Skipping.\n"
            )

    sys.stderr.write(
        f"{len(elements1_by_id)} elements with IDs found in {svg1_path}.\n"
    )
    sys.stderr.write(
        f"{len(elements2_by_id)} elements with IDs found in {svg2_path}.\n"
    )
    sys.stderr.write(
        f"Processed {len(processed_ids)} matching elements for animation.\n"
    )
    sys.stderr.write(f"{animations_added} animation(s) added.\n")

    if is_react_component:
        component_name_prefix = (
            prefix.replace("-", " ").title().replace(" ", "") if prefix else "Animated"
        )
        component_name = f"{component_name_prefix}Icon"

        reactify_svg(root1)
        svg_output_string = ET.tostring(
            root1, encoding="unicode", method="xml", short_empty_elements=True
        ).replace(f'ref="{actual_root_id}"', "ref={svgRef}", count=1)

        return generate_react_component_string(
            svg_output_string, component_name, prefix, actual_root_id
        )
    else:
        ET.tostring(root1, encoding="unicode")

    return svg_output_string


def generate_react_component_string(
    svg_string: str, component_name: str, js_prefix: str, root_svg_id: str
) -> str:
    """
    Generates a React component string embedding the SVG and animation control logic.
    """
    svg_string = svg_string.replace('class="', 'className="')
    # replace 'style="' with 'style={{}}' for React compatibility
    svg_string = re.sub(r'style="([^"]+)"', r"style={{\1}}", svg_string)

    return f"""\

import React, {{ useEffect, useRef }} from 'react';

// Custom hook to get the previous value of a prop or state
function usePrevious(value) {{
  const ref = useRef();
  useEffect(() => {{
    ref.current = value;
  }}, [value]);
  return ref.current;
}}

const {component_name} = ({{ isEnabled }}) => {{
  const svgRef = useRef(null);
  const prevIsEnabled = usePrevious(isEnabled);

  useEffect(() => {{
    if (!svgRef.current) return;
    const svgElement = svgRef.current;
    document.svg = svgElement;

    // Handle initial state on mount
    if (prevIsEnabled === undefined && isEnabled) {{
      // Mounted with isEnabled={{true}}. Snap state.
      const animations = svgElement.querySelectorAll('.{js_prefix}forward-anim');
      animations.forEach(anim => {{
        if (typeof anim.beginElement === 'function') {{
          anim.beginElement();
          const durStr = anim.getAttribute('dur');
          if (durStr) {{
            const durationSec = parseFloat(durStr); // e.g., "1s" -> 1
            if (!isNaN(durationSec) && typeof anim.setCurrentTime === 'function') {{
              anim.setCurrentTime(durationSec); // Jump to end
            }}
          }}
        }}
      }});
    }} else if (prevIsEnabled !== undefined && isEnabled !== prevIsEnabled) {{
      // isEnabled prop has changed after mount
      const animType = isEnabled ? "forward" : "backward";
      const animationsToPlay = svgElement.querySelectorAll(`.{js_prefix}${{animType}}-anim`);
      animationsToPlay?.forEach(anim => {{
        if (typeof anim.beginElement === 'function') {{
          anim.beginElement();
        }}
      }});
    }}
  }}, [isEnabled, prevIsEnabled]);

return ({svg_string});
}}
export default {component_name};"""


def main():
    parser = argparse.ArgumentParser(
        description="Create an SVG with toggle animations between two input SVGs.",
        formatter_class=argparse.RawTextHelpFormatter,
        epilog="""
How the animation works:
- The script compares elements with corresponding IDs in the two SVGs.
- For each matched pair, if attributes like 'd' (for paths), 'style', 'fill',
  'stroke', 'stroke-width', 'opacity', or 'transform' differ,
  SMIL <animate> elements are added to that element in the output SVG.
- By default, animations loop indefinitely (State1 -> State2 -> State1 -> ...).
- The duration for one way of this cycle (e.g., State1 -> State2) can be set.
  The total cycle duration will be double this value.

Example:
  ./svg_animator_v2.py icon_play.svg icon_pause.svg --dur 300ms > animated_icon.svg
  This creates 'animated_icon.svg' that loops between play and pause states,
  with 300ms for play->pause and 300ms for pause->play.

To make the animation trigger on click (single cycle A->B->A):
  ./svg_animator_v2.py svg1.svg svg2.svg --click-to-animate
""",
    )
    parser.add_argument("svg1_path", help="Path to the first SVG file (base state).")
    parser.add_argument("svg2_path", help="Path to the second SVG file (target state).")
    parser.add_argument(
        "--name",
        default="",
        help="prefix used for animation classes. Default: ''.",
    )
    parser.add_argument(
        "--dur",
        default="1s",
        help="Duration for one direction of the animation (e.g., '1s', '500ms'). Default: '1s'. "
        "The full A->B->A cycle will take twice this duration.",
    )
    parser.add_argument(
        "--anim-type",
        type=str,
        choices=["loop", "click", "control", "react"],
        default="loop",
        help="Specify the animation type. 'loop' (default): animation loops on load. "
        "'click': animation triggers on a click and plays one full cycle (A->B->A). "
        "'control': SMIL animations for JS control. "
        "'react': output a React component.",
    )
    parser.add_argument(
        "--root-id",
        help="Specify a custom ID for the root SVG element. Defaults to 'animatedSvgRoot' or the ID from the first SVG if present.",
    )

    args = parser.parse_args()

    output_svg_str = create_animated_svg(
        args.svg1_path,
        args.svg2_path,
        args.dur,
        args.anim_type,
        args.root_id,
        args.name,
    )
    print(output_svg_str)


# Namespace URIs that might be present in the input SVG
# These are common for SVGs edited with Inkscape.
SVG_NS = "http://www.w3.org/2000/svg"
SODIPODI_NS = "http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
INKSCAPE_NS = "http://www.inkscape.org/namespaces/inkscape"
XMLNS_NS = "http://www.w3.org/2000/xmlns/"  # Used by ElementTree for xmlns attributes

# Mappings for attribute name conversion from ElementTree's {uri}localname
# to the desired flattened camelCase name (e.g., sodipodiDocname).
# This reflects the transformations seen in the JSX fix.
ATTR_NAME_MAP = {
    f"{{{SODIPODI_NS}}}docname": "sodipodiDocname",
    f"{{{INKSCAPE_NS}}}version": "inkscapeVersion",
    f"{{{INKSCAPE_NS}}}label": "inkscapeLabel",
    f"{{{INKSCAPE_NS}}}groupmode": "inkscapeGroupmode",
    f"{{{INKSCAPE_NS}}}transform-center-x": "inkscapeTransformCenterX",
    f"{{{INKSCAPE_NS}}}transform-center-y": "inkscapeTransformCenterY",
    # Add other ns1/ns2 mappings if they corresponded to other URIs/attributes
}

# Tags to be removed (using ElementTree's fully qualified {uri}tag format)
TAGS_TO_REMOVE_QUALIFIED = {
    f"{{{SODIPODI_NS}}}namedview",
    f"{{{SODIPODI_NS}}}guide",
    f"{{{INKSCAPE_NS}}}grid",
}
# Specific handling for empty <defs> tag
SVG_DEFS_TAG_QUALIFIED = f"{{{SVG_NS}}}defs"

# Namespace prefixes on the root SVG element that should be removed
# (e.g., xmlns:sodipodi, xmlns:inkscape, xmlns:ns1, xmlns:ns2)
ROOT_NS_PREFIXES_TO_REMOVE = ["sodipodi", "inkscape", "ns1", "ns2"]


def _camel_case_css_property(name):
    """Converts a kebab-case CSS property name to camelCase."""
    parts = name.split("-")
    return parts[0] + "".join(p.capitalize() for p in parts[1:])


def _format_css_value_for_jsx_object(value_str):
    """
    Formats a CSS value string for inclusion in a JavaScript-like object string.
    Numbers are unquoted; strings are single-quoted.
    """
    try:
        num_val = float(value_str)
        if num_val.is_integer():
            return str(int(num_val))
        else:
            # Format float concisely, removing trailing .0 but keeping other decimals
            return (
                f"{num_val:.10g}".rstrip("0").rstrip(".")
                if "." in f"{num_val:.10g}"
                else f"{num_val:.0f}"
            )

    except ValueError:  # Not a number, treat as string
        # Add single quotes if not already quoted
        if not (
            (value_str.startswith("'") and value_str.endswith("'"))
            or (value_str.startswith('"') and value_str.endswith('"'))
        ):
            # Escape single quotes within the string if necessary
            return f"'{value_str.replace("'", "\\'")}'"
        return value_str


def _process_element_recursive_inplace(element, is_root):
    """
    Recursively processes an XML element and its children in place.
    - Removes specified namespaced tags and empty <defs>.
    - Converts namespaced attributes to camelCase.
    - Removes specified xmlns declarations from the root.
    - Transforms 'style' attribute strings into a JavaScript-like object string format.
    """
    # 1. Process attributes of the current element
    current_attrs = list(element.attrib.items())  # Iterate over a copy
    new_attrs = {}

    for key, value in current_attrs:
        attr_removed_or_transformed = False
        # Handle root xmlns attribute removal
        if is_root:
            # Check for xmlns:prefix attributes
            if (
                key.startswith("xmlns:")
                and key.split(":", 1)[1] in ROOT_NS_PREFIXES_TO_REMOVE
            ):
                attr_removed_or_transformed = True
            # Check for ElementTree's {uri}prefix representation of xmlns attributes
            elif (
                key.startswith(f"{{{XMLNS_NS}}}")
                and key.split("}", 1)[1] in ROOT_NS_PREFIXES_TO_REMOVE
            ):
                attr_removed_or_transformed = True

        if attr_removed_or_transformed:
            continue

        if key == "style":
            style_rules_for_jsx_obj = []
            css_declarations = [
                decl.strip() for decl in value.split(";") if decl.strip()
            ]
            for part in css_declarations:
                try:
                    name, val_str = part.split(":", 1)
                    name = name.strip()
                    val_str = val_str.strip()

                    camel_name = _camel_case_css_property(name)
                    formatted_val = _format_css_value_for_jsx_object(val_str)
                    style_rules_for_jsx_obj.append(f"{camel_name}:{formatted_val}")
                except ValueError:
                    # If a style part is not 'name:value', it's unusual.
                    # For robustness, one might log this or skip. Here, we skip.
                    pass
            new_attrs[key] = ", ".join(style_rules_for_jsx_obj)
            attr_removed_or_transformed = True
        elif key in ATTR_NAME_MAP:  # Mapped namespaced attributes
            new_attrs[ATTR_NAME_MAP[key]] = value
            attr_removed_or_transformed = True

        if not attr_removed_or_transformed:  # Keep unmapped attributes
            new_attrs[key] = value

    element.attrib.clear()
    element.attrib.update(new_attrs)

    # 2. Process children: Iterate backwards for safe removal while modifying
    for i in range(len(element) - 1, -1, -1):
        child = element[i]

        if child.tag in TAGS_TO_REMOVE_QUALIFIED:
            element.remove(child)
            continue
        if child.tag == SVG_DEFS_TAG_QUALIFIED and not list(child):  # Empty <defs>
            element.remove(child)
            continue

        _process_element_recursive_inplace(
            child, False
        )  # Recurse for children that are kept


def reactify_svg(root_element_et):
    """
    Takes an xml.etree.ElementTree.Element representing an SVG,
    applies transformations inspired by JSX fixes (style attributes, namespaces),
    and returns the modified SVG as a string.

    Args:
        root_element_et: The root Element of the SVG ElementTree.

    Returns:
        A string representation of the modified SVG.
    """
    if not isinstance(root_element_et, ET.Element):
        raise TypeError("Input must be an xml.etree.ElementTree.Element")

    # Deepcopy to avoid modifying the original ElementTree object passed in
    # root_copy = copy.deepcopy(root_element_et)

    _process_element_recursive_inplace(root_element_et, True)

    # Serialize the modified tree to a string.
    # method='xml' is standard. short_empty_elements=True helps ensure <tag/> for empty tags.
    # return ET.tostring(
    #     root_copy, encoding="unicode", method="xml", short_empty_elements=True
    # )


if __name__ == "__main__":
    main()
