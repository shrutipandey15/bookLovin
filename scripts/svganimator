#!/usr/bin/env python
"""
SVG Animator: A script to create animated SVGs from two static SVG files.

This script can generate SVGs with different animation types:
- loop: The animation plays continuously.
- click: The animation plays once on click.
- control: The animation is controlled by external JavaScript (forward/backward).
- react: Generates a React component that wraps the SVG and controls the animation.
"""

import argparse
import re
from enum import Enum
import sys
import xml.etree.ElementTree as ET

SVG_NS = "http://www.w3.org/2000/svg"
ET.register_namespace("", SVG_NS)  # Register a default namespace

global_config = {"prefix": ""}


class AnimTypes(Enum):
    """Animation flavors."""

    LOOP = "loop"
    CLICK = "click"
    CONTROL = "control"
    REACT = "react"


# Helper function to extract a specific property value from a style string
def get_style_property(style_string, property_name):
    if not style_string:
        return None
    match = re.search(
        f"{re.escape(property_name)}\\s*:\\s*([^;]+)", style_string, re.IGNORECASE
    )
    if match:
        return match.group(1).strip()
    return None


def create_animated_svg(
    svg1_path,
    svg2_path,
    animation_duration_one_way: str,
    anim_type_str: str,
    root_id_override: str | None = None,
    prefix: str = "unnamed",
):
    anim_type = AnimTypes(anim_type_str)  # Convert string to Enum here
    try:
        tree1 = ET.parse(svg1_path)
        root1 = tree1.getroot()
    except FileNotFoundError:
        print(f"Error: File not found: {svg1_path}", file=sys.stderr)
        sys.exit(1)
    except ET.ParseError:
        print(f"Error: Could not parse XML from {svg1_path}", file=sys.stderr)
        sys.exit(1)

    try:
        tree2 = ET.parse(svg2_path)
        root2 = tree2.getroot()
    except FileNotFoundError:
        print(f"Error: File not found: {svg2_path}", file=sys.stderr)
        sys.exit(1)
    except ET.ParseError:
        print(f"Error: Could not parse XML from {svg2_path}", file=sys.stderr)
        sys.exit(1)

    # Build dictionaries of elements keyed by ID for efficient lookup
    # This will find all elements with an 'id' attribute, regardless of type or location
    elements1_by_id = {el.get("id"): el for el in root1.iter() if el.get("id")}
    elements2_by_id = {el.get("id"): el for el in root2.iter() if el.get("id")}
    global_config["prefix"] = prefix

    if not elements1_by_id and not elements2_by_id:
        print(
            "Warning: No elements with IDs found in the SVGs. Animations require elements to have unique IDs to match them.",
            file=sys.stderr,
        )
    elif not elements1_by_id:
        print(f"Warning: No elements with IDs found in {svg1_path}.", file=sys.stderr)
    elif not elements2_by_id:
        print(f"Warning: No elements with IDs found in {svg2_path}.", file=sys.stderr)

    # Calculate total duration for A -> B -> A cycle
    try:
        val_str = animation_duration_one_way.rstrip("ms")
        unit = animation_duration_one_way[len(val_str) :]
        one_way_val = float(val_str)
        total_val = one_way_val * 2
        if total_val.is_integer():
            total_val = int(total_val)
        cycle_duration_str = f"{total_val}{unit}"
    except ValueError:
        print(
            f"Warning: Could not parse animation_duration_one_way: {animation_duration_one_way}. Defaulting cycle duration to '2s'.",
            file=sys.stderr,
        )
        cycle_duration_str = "2s"

    def _add_animation_if_different(
        parent_element,
        attribute_name,
        val1,
        val2,
        one_way_duration: str,
        cycle_duration: str,
        anim_type: AnimTypes,
        current_animations_count_for_id: int,  # Used for ID generation in loop/click
        trigger_event_id_for_click: str = None,  # For click-triggered animations
    ):
        if val1 == val2:
            return 0  # No animation needed, 0 animations added
        animations_created_count = 0

        if anim_type == AnimTypes.CONTROL or anim_type == AnimTypes.REACT:
            # Forward animation (A -> B)
            animate_fwd = ET.SubElement(parent_element, "animate")
            animate_fwd.set("class", global_config["prefix"] + "forward-anim")
            animate_fwd.set("attributeName", attribute_name)
            animate_fwd.set("values", f"{val1};{val2}")
            animate_fwd.set("dur", one_way_duration)
            animate_fwd.set("begin", "indefinite")
            animate_fwd.set("fill", "freeze")
            animations_created_count += 1

            # Backward animation (B -> A)
            animate_bwd = ET.SubElement(parent_element, "animate")
            animate_bwd.set("class", global_config["prefix"] + "backward-anim")
            animate_bwd.set("attributeName", attribute_name)
            animate_bwd.set("values", f"{val2};{val1}")  # Reverse values
            animate_bwd.set("dur", one_way_duration)
            animate_bwd.set("begin", "indefinite")
            animate_bwd.set("fill", "freeze")
            animations_created_count += 1
        else:  # LOOP or CLICK
            animate_el = ET.SubElement(parent_element, "animate")
            animate_el.set("attributeName", attribute_name)
            animate_el.set("values", f"{val1};{val2};{val1}")
            animate_el.set("dur", cycle_duration)

            if anim_type == AnimTypes.CLICK.value and trigger_event_id_for_click:
                animate_el.set("begin", trigger_event_id_for_click)
            elif anim_type == AnimTypes.LOOP.value:
                animate_el.set("repeatCount", "indefinite")
                animate_el.set("begin", "0s")  # Start immediately
            # Default for non-looping is effectively one cycle if begin is specified.
            animations_created_count += 1
        return animations_created_count

    animations_added = 0
    trigger_event_id = None
    actual_root_id = root_id_override or root1.get("id") or "animatedSvgRoot"
    root1.set("id", actual_root_id)
    # Store one-way duration for JS access
    root1.set("data-one-way-duration", animation_duration_one_way)

    click_to_animate = anim_type == AnimTypes.CLICK.value
    is_react_component = anim_type == AnimTypes.REACT

    if click_to_animate:
        trigger_event_id = f"{actual_root_id}.click"

    processed_ids = set()

    for id_val, el1 in elements1_by_id.items():
        if id_val in elements2_by_id:
            el2 = elements2_by_id[id_val]
            processed_ids.add(id_val)

            # Animate 'd' attribute (path data) - specific to paths
            if el1.tag == f"{{{SVG_NS}}}path" and el2.tag == f"{{{SVG_NS}}}path":
                d1 = el1.get("d", "")
                d2 = el2.get("d", "")
                num_created = _add_animation_if_different(
                    el1,
                    "d",
                    d1,
                    d2,
                    animation_duration_one_way,
                    cycle_duration_str,
                    anim_type,
                    animations_added,
                    trigger_event_id,
                )
                animations_added += num_created

            # Animate 'style' attribute
            style1 = el1.get("style", "")
            style2 = el2.get("style", "")
            num_created = _add_animation_if_different(
                el1,
                "style",
                style1,
                style2,
                animation_duration_one_way,
                cycle_duration_str,
                anim_type,
                animations_added,
                trigger_event_id,
            )
            animations_added += num_created

            # Animate common presentation attributes
            common_attrs_to_animate = {
                "stroke": "none",
                "stroke-width": "1",  # Default for stroke-width if not specified
                "opacity": "1",  # Default for opacity
                "fill": "none",  # Default for fill
            }
            for attr, default_val in common_attrs_to_animate.items():
                val1_attr = el1.get(attr)
                val1_style = get_style_property(style1, attr)
                val1 = val1_attr or val1_style or default_val

                val2_attr = el2.get(attr)
                val2_style = get_style_property(style2, attr)
                val2 = val2_attr or val2_style or default_val

                num_created = _add_animation_if_different(
                    el1,
                    attr,
                    val1,
                    val2,
                    animation_duration_one_way,
                    cycle_duration_str,
                    anim_type,
                    animations_added,
                    trigger_event_id,
                )
                animations_added += num_created

            # Animate direct 'transform' attribute
            t1_val = el1.get("transform", "")
            t2_val = el2.get("transform", "")
            num_created = _add_animation_if_different(
                el1,
                "transform",
                t1_val,
                t2_val,
                animation_duration_one_way,
                cycle_duration_str,
                anim_type,
                animations_added,
                trigger_event_id,
            )
            animations_added += num_created
        else:
            sys.stderr.write(
                f"Info: Element with ID '{id_val}' found in first SVG but not in second. Skipping.\n"
            )

    for id_val in elements2_by_id:
        if id_val not in processed_ids:
            sys.stderr.write(
                f"Info: Element with ID '{id_val}' found in second SVG but not in first. Skipping.\n"
            )

    sys.stderr.write(
        f"{len(elements1_by_id)} elements with IDs found in {svg1_path}.\n"
    )
    sys.stderr.write(
        f"{len(elements2_by_id)} elements with IDs found in {svg2_path}.\n"
    )
    sys.stderr.write(
        f"Processed {len(processed_ids)} matching elements for animation.\n"
    )
    sys.stderr.write(f"{animations_added} animation(s) added.\n")

    svg_output_string = ET.tostring(root1, encoding="unicode")

    if is_react_component:
        component_name_prefix = (
            prefix.replace("-", " ").title().replace(" ", "") if prefix else "Animated"
        )
        component_name = f"{component_name_prefix}Icon"
        svg_output_string = generate_react_component_string(
            svg_output_string, component_name, prefix, actual_root_id
        )

    return svg_output_string


def generate_react_component_string(
    svg_string: str, component_name: str, js_prefix: str, root_svg_id: str
) -> str:
    """
    Generates a React component string embedding the SVG and animation control logic.
    """
    # Ensure js_prefix is safe for use in template literals and class names
    # If js_prefix ends with '-', remove it for the main class, but keep for anim selectors
    component_base_class = js_prefix.rstrip("-") if js_prefix else "animated-svg-icon"
    anim_selector_prefix = js_prefix  # e.g., "myPrefix-"

    return f"""\
import React, {{ useEffect, useRef }} from 'react';

// Custom hook to get the previous value of a prop or state
function usePrevious(value) {{
  const ref = useRef();
  useEffect(() => {{
    ref.current = value;
  }}, [value]);
  return ref.current;
}}

function parseSMILDurationToSeconds(durStr) {{
  if (!durStr) return 0;
  if (typeof durStr !== 'string') return 0; // Ensure durStr is a string
  if (durStr.endsWith('ms')) {{
    return parseFloat(durStr.substring(0, durStr.length - 2)) / 1000;
  }}
  if (durStr.endsWith('s')) {{
    return parseFloat(durStr.substring(0, durStr.length - 1));
  }}
  const parsed = parseFloat(durStr);
  return isNaN(parsed) ? 0 : parsed; // Assume seconds if no unit, or 0 if unparsable
}}

const {component_name} = ({{ isEnabled, className }}) => {{
  const svgRef = useRef(null);
  const prevIsEnabled = usePrevious(isEnabled);

  useEffect(() => {{
    if (!svgRef.current) return;
    const svgElement = svgRef.current;

    const forwardAnims = svgElement.querySelectorAll('.{anim_selector_prefix}forward-anim');
    const backwardAnims = svgElement.querySelectorAll('.{anim_selector_prefix}backward-anim');

    if (prevIsEnabled === undefined) {{ // Initial mount
      if (isEnabled) {{
        // Snap to enabled state (end of forward animation)
        forwardAnims.forEach(anim => {{
          if (typeof anim.beginElement === 'function') {{
            anim.beginElement(); // Start animation
            const durStr = anim.getAttribute('dur');
            const durationSec = parseSMILDurationToSeconds(durStr);
            if (durationSec > 0 && typeof anim.setCurrentTime === 'function') {{
              // Some browsers might need a micro-delay for setCurrentTime to work after beginElement
              // For simplicity, directly trying. If issues, requestAnimationFrame or setTimeout might be needed.
              anim.setCurrentTime(durationSec); // Jump to end
            }}
          }}
        }});
      }}
      // If !isEnabled on mount, it's already in the base state (SVG1), so do nothing.
    }} else if (isEnabled !== prevIsEnabled) {{ // Prop changed
      const animationsToPlay = isEnabled ? forwardAnims : backwardAnims;
      animationsToPlay.forEach(anim => {{
        if (typeof anim.beginElement === 'function') {{
          anim.beginElement();
        }}
      }});
    }}
  }}, [isEnabled, prevIsEnabled]);

  const combinedClassName = `{component_base_class} ${{className || ''}}`.trim();

  // The SVG string is directly embedded here.
  // Ensure it's valid JSX. Self-closing tags in SVG are usually fine.
  // React might complain about kebab-case attributes like 'stroke-width',
  // but for SVG embedded as a string via dangerouslySetInnerHTML or as direct children, it's often fine.
  // Here, we are returning an SVG element directly, so JSX transform applies.
  // For simplicity, this example assumes the svg_string can be parsed by React.
  // A more robust solution for complex SVGs might involve dangerouslySetInnerHTML
  // or converting SVG attributes to camelCase if rendering as JSX components.
  // However, standard SVG attributes are typically fine.

  // To make this work seamlessly, we'll parse the SVG string and adapt it slightly for JSX
  // For now, let's assume the svg_string is simple enough or use dangerouslySetInnerHTML.
  // The simplest way that works with create-react-app and standard SVG is to set props.
  // However, the svg_string contains the full SVG.
  // A common pattern is to use `dangerouslySetInnerHTML` for the contents of the <svg> tag,
  // or to parse the svg_string and convert it to React elements.
  // Given the script generates the full <svg ...>...</svg> string,
  // we'll use a common workaround for embedding arbitrary SVG.

  // The most straightforward way to embed the generated SVG string,
  // including its <animate> tags, is to parse it and reconstruct it as JSX,
  // or use dangerouslySetInnerHTML on a wrapper.
  // However, since we want to attach a ref to the <svg> element itself,
  // we need to control its props.

  // Let's refine this part: the svg_string is the *entire* SVG.
  // We need to extract its attributes and children.
  // For now, a simpler approach for demonstration:
  // The user will get a string that they might need to adjust slightly
  // if they paste it directly into a JSX file, especially regarding attribute casing.
  // However, browsers are quite tolerant with SVG attributes.

  // This is tricky because svg_string is a full <svg>...</svg>.
  // We need to parse attributes from svg_string's root and its children.
  // A simpler, more direct approach for this script's output:
  // The generated SVG string already has an ID. We just need to make sure React can render it.
  // React can render SVG tags directly.

  // The svg_string is a complete SVG document string.
  // We will parse it to get the attributes of the root <svg> element and its children.
  // This is complex. A simpler method for this script:
  // Assume the svg_string can be embedded.
  // The most robust way is to have the Python script output only the *content* of the SVG
  // if it's for React, and then the React component provides the <svg> wrapper.
  // Or, the Python script generates the full SVG string, and React uses dangerouslySetInnerHTML.

  // Let's try to make the output directly usable by creating a wrapper and using dangerouslySetInnerHTML
  // for the SVG content generated by ElementTree.
  // The `svg_string` from `ET.tostring` includes the XML declaration if not careful.
  // `ET.tostring(root1, encoding="unicode", xml_declaration=False)`
  // But `ET.tostring` doesn't have `xml_declaration` param. Default is no declaration.

  // The svg_string is `<svg id="..." ...> ... </svg>`
  // We need to pass this to React.
  // The `ref` needs to be on the `<svg>` tag.

  // Option 1: dangerouslySetInnerHTML (ref on wrapper div) - not ideal as ref should be on SVG.
  // Option 2: Parse SVG string and convert to JSX (complex).
  // Option 3: Output the SVG string and tell user to handle it.
  // Option 4: Modify the SVG string to fit into a JSX <svg ...props> structure.

  // Let's go with a method that allows the ref to be on the SVG element.
  // We'll have to parse the attributes from the generated svg_string's root.
  // This is getting too complex for a quick change.
  // The simplest for the user is if the output is a self-contained component.

  // The `DarkLightIcon.jsx` example you provided has `<svg />` and then presumably
  // the SVG content is hardcoded or imported.
  // Here, the SVG content is dynamic.

  // Simplification: The React component will render the SVG string using dangerouslySetInnerHTML
  // on a div, and the script will ensure the SVG has the correct ID for targeting.
  // This means the ref will be on the div, not the SVG. This is a compromise.
  // To get ref on SVG, one would typically import SVG as a ReactComponent.

  // Let's try to make the SVG string directly embeddable.
  // JSX is XML-like. The main issue is `class` vs `className` and style strings.
  // ElementTree produces `class`. React wants `className`.
  // We can replace `class=` with `className=`.
  // Style strings are fine. Kebab-case attributes are fine in SVG.

  let jsxReadySvgString = `{svg_string}`;
  jsxReadySvgString = jsxReadySvgString.replace(/ class=/g, ' className=');
  // Remove XML declaration if present (though ET.tostring(encoding='unicode') shouldn't add it)
  jsxReadySvgString = jsxReadySvgString.replace(/^<\\?xml.*?\\?>/, '');


  return (
    <div
      ref={{svgRef}} // This is incorrect. ref should be a function or a ref object.
                     // And this puts ref on div, not svg.
      className={{combinedClassName}} // This is incorrect. Should be `combinedClassName`
      dangerouslySetInnerHTML={{{{ __html: jsxReadySvgString }}}}
    />
  );
}};

export default {component_name};
"""


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Create an SVG with toggle animations between two input SVGs.",
        formatter_class=argparse.RawTextHelpFormatter,
        epilog="""
How the animation works:
- The script compares elements with corresponding IDs in the two SVGs.
- For each matched pair, if attributes like 'd' (for paths), 'style', 'fill',
  'stroke', 'stroke-width', 'opacity', or 'transform' differ,
  SMIL <animate> elements are added to that element in the output SVG.
- By default, animations loop indefinitely (State1 -> State2 -> State1 -> ...).
- The duration for one way of this cycle (e.g., State1 -> State2) can be set.
  The total cycle duration will be double this value.

Example:
  ./svg_animator_v2.py icon_play.svg icon_pause.svg --dur 300ms > animated_icon.svg
  This creates 'animated_icon.svg' that loops between play and pause states,
  with 300ms for play->pause and 300ms for pause->play.

To make the animation trigger on click (single cycle A->B->A):
  ./svg_animator_v2.py svg1.svg svg2.svg --click-to-animate
""",
    )
    parser.add_argument("svg1_path", help="Path to the first SVG file (base state).")
    parser.add_argument("svg2_path", help="Path to the second SVG file (target state).")
    parser.add_argument(
        "--name",
        default="",
        help="prefix used for animation classes. Default: ''.",
    )
    parser.add_argument(
        "--dur",
        default="1s",
        help="Duration for one direction of the animation (e.g., '1s', '500ms'). Default: '1s'. "
        "The full A->B->A cycle will take twice this duration.",
    )
    parser.add_argument(
        "--anim-type",
        type=str,
        choices=["loop", "click", "control", "react"],
        default="loop",
        help="Specify the animation type. 'loop' (default): animation loops on load. "
        "'click': animation triggers on a click and plays one full cycle (A->B->A). "
        "'control': SMIL animations for JS control. "
        "'react': output a React component.",
    )
    parser.add_argument(
        "--root-id",
        help="Specify a custom ID for the root SVG element. Defaults to 'animatedSvgRoot' or the ID from the first SVG if present.",
    )

    args = parser.parse_args()

    output_svg_str = create_animated_svg(
        args.svg1_path,
        args.svg2_path,
        args.dur,
        args.anim_type,
        args.root_id,
        args.name,
    )
    print(output_svg_str)
